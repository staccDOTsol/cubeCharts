// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "market_data.proto" (package "md", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Every exchange message from `/book/:market_id` will be wrapped as an
 * [`MdMessages`](#md-messages) which contains multiple `MdMessage`'s.
 *
 * @generated from protobuf message md.MdMessage
 */
export interface MdMessage {
    /**
     * @generated from protobuf oneof: inner
     */
    inner: {
        oneofKind: "heartbeat";
        /**
         * Server heartbeat reply
         *
         * @generated from protobuf field: md.Heartbeat heartbeat = 1;
         */
        heartbeat: Heartbeat;
    } | {
        oneofKind: "summary";
        /**
         * 24h summary
         *
         * @generated from protobuf field: md.Summary summary = 2;
         */
        summary: Summary;
    } | {
        oneofKind: "trades";
        /**
         * Recent trades
         *
         * @generated from protobuf field: md.Trades trades = 3;
         */
        trades: Trades;
    } | {
        oneofKind: "mboSnapshot";
        /**
         * Market by order snapshot
         *
         * @generated from protobuf field: md.MarketByOrder mboSnapshot = 4;
         */
        mboSnapshot: MarketByOrder;
    } | {
        oneofKind: "mboDiff";
        /**
         * Market by order diff
         *
         * @generated from protobuf field: md.MarketByOrderDiff mboDiff = 5;
         */
        mboDiff: MarketByOrderDiff;
    } | {
        oneofKind: "mbpSnapshot";
        /**
         * Market by price snapshot
         *
         * @generated from protobuf field: md.MarketByPrice mbpSnapshot = 6;
         */
        mbpSnapshot: MarketByPrice;
    } | {
        oneofKind: "mbpDiff";
        /**
         * Market by price diff
         *
         * @generated from protobuf field: md.MarketByPriceDiff mbpDiff = 7;
         */
        mbpDiff: MarketByPriceDiff;
    } | {
        oneofKind: "kline";
        /**
         * Candlestick
         *
         * @generated from protobuf field: md.Kline kline = 8;
         */
        kline: Kline;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Market by price snapshot message. This is chunked into `numChunks` and starts
 * with `chunk = 0`. A snapshot is sent on first connect. `Level`'s should be
 * concatened until `chunk = numChunks - 1`. Currently, the chunks and levels
 * are streamed from tightest price level outwards with interleaved Bid and Ask
 * levels, but no ordering is guaranteed.
 *
 * @generated from protobuf message md.MarketByPrice
 */
export interface MarketByPrice {
    /**
     * @generated from protobuf field: repeated md.MarketByPrice.Level levels = 1;
     */
    levels: MarketByPrice_Level[];
    /**
     * @generated from protobuf field: uint32 chunk = 2;
     */
    chunk: number;
    /**
     * @generated from protobuf field: uint32 numChunks = 3;
     */
    numChunks: number;
}
/**
 * Each price level is the aggregate total quantity of orders placed at that
 * price.
 *
 * @generated from protobuf message md.MarketByPrice.Level
 */
export interface MarketByPrice_Level {
    /**
     * @generated from protobuf field: uint64 price = 1;
     */
    price: bigint;
    /**
     * @generated from protobuf field: uint64 quantity = 2;
     */
    quantity: bigint;
    /**
     * @generated from protobuf field: md.Side side = 3;
     */
    side: Side;
}
/**
 * Market by price diff message. Book updates for the MBP feed are sent as diffs
 * after the initial snapshot. The number of total side levels are for
 * reconciliation.
 *
 * @generated from protobuf message md.MarketByPriceDiff
 */
export interface MarketByPriceDiff {
    /**
     * @generated from protobuf field: repeated md.MarketByPriceDiff.Diff diffs = 1;
     */
    diffs: MarketByPriceDiff_Diff[];
    /**
     * Total number of bid levels after this diff is applied.
     *
     * @generated from protobuf field: uint32 totalBidLevels = 2;
     */
    totalBidLevels: number;
    /**
     * Total number of ask levels after this diff is applied.
     *
     * @generated from protobuf field: uint32 totalAskLevels = 3;
     */
    totalAskLevels: number;
}
/**
 * A price level diff overwrites the existing price level.
 *
 * @generated from protobuf message md.MarketByPriceDiff.Diff
 */
export interface MarketByPriceDiff_Diff {
    /**
     * @generated from protobuf field: uint64 price = 1;
     */
    price: bigint;
    /**
     * @generated from protobuf field: uint64 quantity = 2;
     */
    quantity: bigint;
    /**
     * @generated from protobuf field: md.Side side = 3;
     */
    side: Side;
    /**
     * @generated from protobuf field: md.MarketByPriceDiff.DiffOp op = 4;
     */
    op: MarketByPriceDiff_DiffOp;
}
/**
 * The operation to apply for this price level. Currently, new price levels
 * are created with `REPLACE`.
 *
 * @generated from protobuf enum md.MarketByPriceDiff.DiffOp
 */
export enum MarketByPriceDiff_DiffOp {
    /**
     * @generated from protobuf enum value: ADD = 0;
     */
    ADD = 0,
    /**
     * @generated from protobuf enum value: REMOVE = 1;
     */
    REMOVE = 1,
    /**
     * @generated from protobuf enum value: REPLACE = 2;
     */
    REPLACE = 2
}
/**
 * Market by order snapshot message. This is chunked into `numChunks` and starts
 * with `chunk = 0`. A snapshot is sent on first connect. `Level`'s should be
 * concatened until `chunk = numChunks - 1`. Orders are sent in order of FIFO
 * queue priority so the first order of a level should be the first order to be
 * matched when that level is aggressed.
 *
 * @generated from protobuf message md.MarketByOrder
 */
export interface MarketByOrder {
    /**
     * @generated from protobuf field: repeated md.MarketByOrder.Order orders = 1;
     */
    orders: MarketByOrder_Order[];
    /**
     * @generated from protobuf field: uint32 chunk = 2;
     */
    chunk: number;
    /**
     * @generated from protobuf field: uint32 numChunks = 3;
     */
    numChunks: number;
}
/**
 * A resting order.
 *
 * @generated from protobuf message md.MarketByOrder.Order
 */
export interface MarketByOrder_Order {
    /**
     * @generated from protobuf field: uint64 price = 1;
     */
    price: bigint;
    /**
     * @generated from protobuf field: uint64 quantity = 2;
     */
    quantity: bigint;
    /**
     * [Exchange order ID](/docs/api_reference/trade#exchange-order-id)
     *
     * @generated from protobuf field: uint64 exchangeOrderId = 3;
     */
    exchangeOrderId: bigint;
    /**
     * @generated from protobuf field: md.Side side = 4;
     */
    side: Side;
}
/**
 * Market by order diff message. Book updates for the MBO feed are sent as diffs
 * after the initial snapshot. The number of total side levels and orders are
 * for reconciliation.
 *
 * Note that for orders that are cancel-replace'd (a modify that lost queue
 * priority), the new price and quantity will be reported as a `REPLACE` but the
 * exchange order ID will not change.
 *
 * @generated from protobuf message md.MarketByOrderDiff
 */
export interface MarketByOrderDiff {
    /**
     * @generated from protobuf field: repeated md.MarketByOrderDiff.Diff diffs = 1;
     */
    diffs: MarketByOrderDiff_Diff[];
    /**
     * Total number of bid levels after this diff is applied.
     *
     * @generated from protobuf field: uint32 totalBidLevels = 2;
     */
    totalBidLevels: number;
    /**
     * Total number of ask levels after this diff is applied.
     *
     * @generated from protobuf field: uint32 totalAskLevels = 3;
     */
    totalAskLevels: number;
    /**
     * Total number of bid orders after this diff is applied.
     *
     * @generated from protobuf field: uint32 totalBidOrders = 4;
     */
    totalBidOrders: number;
    /**
     * Total number of ask orders after this diff is applied.
     *
     * @generated from protobuf field: uint32 totalAskOrders = 5;
     */
    totalAskOrders: number;
}
/**
 * @generated from protobuf message md.MarketByOrderDiff.Diff
 */
export interface MarketByOrderDiff_Diff {
    /**
     * @generated from protobuf field: uint64 price = 1;
     */
    price: bigint;
    /**
     * @generated from protobuf field: uint64 quantity = 2;
     */
    quantity: bigint;
    /**
     * [Exchange order ID](/docs/api_reference/trade#exchange-order-id)
     *
     * @generated from protobuf field: uint64 exchangeOrderId = 3;
     */
    exchangeOrderId: bigint;
    /**
     * @generated from protobuf field: md.Side side = 4;
     */
    side: Side;
    /**
     * @generated from protobuf field: md.MarketByOrderDiff.OrderOp op = 5;
     */
    op: MarketByOrderDiff_OrderOp;
}
/**
 * @generated from protobuf enum md.MarketByOrderDiff.OrderOp
 */
export enum MarketByOrderDiff_OrderOp {
    /**
     * @generated from protobuf enum value: ADD = 0;
     */
    ADD = 0,
    /**
     * @generated from protobuf enum value: REMOVE = 1;
     */
    REMOVE = 1,
    /**
     * @generated from protobuf enum value: REPLACE = 2;
     */
    REPLACE = 2
}
/**
 * Trades since the latest `Trades` message. The result of the trades will also
 * appear in the MBP and MBO feeds independently as updates to the resting
 * orders and levels, respectively.
 *
 * @generated from protobuf message md.Trades
 */
export interface Trades {
    /**
     * @generated from protobuf field: repeated md.Trades.Trade trades = 1;
     */
    trades: Trades_Trade[];
}
/**
 * @generated from protobuf message md.Trades.Trade
 */
export interface Trades_Trade {
    /**
     * The ID assigned to this trade. All trades that occur from the same event
     * will be assigned the same ID, and are considered to be an atomic batch.
     *
     * @generated from protobuf field: uint64 tradeId = 1;
     */
    tradeId: bigint;
    /**
     * The price that this trade occurred at.
     *
     * @generated from protobuf field: uint64 price = 2;
     */
    price: bigint;
    /**
     * The side of the aggressing order.
     *
     * @generated from protobuf field: md.Side aggressingSide = 3;
     */
    aggressingSide: Side;
    /**
     * The [Exchange order ID](/docs/api_reference/trade#exchange-order-id) of
     * the resting order.
     *
     * @generated from protobuf field: uint64 restingExchangeOrderId = 4;
     */
    restingExchangeOrderId: bigint;
    /**
     * @generated from protobuf field: uint64 fillQuantity = 5;
     */
    fillQuantity: bigint;
    /**
     * The [transact time](/docs/api_reference/trade#transact-time) assigned by
     * the matching engine for this trade. All trades that occur from the same
     * event will be assigned the same transact time.
     *
     * @generated from protobuf field: uint64 transactTime = 6;
     */
    transactTime: bigint;
    /**
     * The [Exchange order ID](/docs/api_reference/trade#exchange-order-id) of
     * the aggressing order.
     *
     * @generated from protobuf field: uint64 aggressingExchangeOrderId = 7;
     */
    aggressingExchangeOrderId: bigint;
}
/**
 * Rolling 24h stats.
 *
 * @generated from protobuf message md.Summary
 */
export interface Summary {
    /**
     * Low price
     *
     * @generated from protobuf field: uint64 low = 1;
     */
    low: bigint;
    /**
     * High price
     *
     * @generated from protobuf field: uint64 high = 2;
     */
    high: bigint;
    /**
     * Low 64-bits of the base quantity traded
     *
     * @generated from protobuf field: uint64 baseVolumeLo = 3;
     */
    baseVolumeLo: bigint;
    /**
     * High 64-bits of the base quantity traded
     *
     * @generated from protobuf field: uint64 baseVolumeHi = 4;
     */
    baseVolumeHi: bigint;
    /**
     * Low 64-bits of the quote quantity traded
     *
     * @generated from protobuf field: uint64 quoteVolumeLo = 5;
     */
    quoteVolumeLo: bigint;
    /**
     * High 64-bits of the quote quantity traded
     *
     * @generated from protobuf field: uint64 quoteVolumeHi = 6;
     */
    quoteVolumeHi: bigint;
}
/**
 * Candlestick bar.
 *
 * @generated from protobuf message md.Kline
 */
export interface Kline {
    /**
     * @generated from protobuf field: md.KlineInterval interval = 1;
     */
    interval: KlineInterval;
    /**
     * The unix nanosecond timestamp that this kline covers.
     *
     * @generated from protobuf field: uint64 startTime = 2;
     */
    startTime: bigint;
    /**
     * Kline open price.
     *
     * @generated from protobuf field: uint64 open = 3;
     */
    open: bigint;
    /**
     * Kline close price.
     *
     * @generated from protobuf field: uint64 close = 4;
     */
    close: bigint;
    /**
     * Kline high price.
     *
     * @generated from protobuf field: uint64 high = 5;
     */
    high: bigint;
    /**
     * Kline low price.
     *
     * @generated from protobuf field: uint64 low = 6;
     */
    low: bigint;
    /**
     * Low 64-bits of the base quantity traded.
     *
     * @generated from protobuf field: uint64 volumeLo = 7;
     */
    volumeLo: bigint;
    /**
     * High 64-bits of the base quantity traded.
     *
     * @generated from protobuf field: uint64 volumeHi = 8;
     */
    volumeHi: bigint;
}
/**
 * A client and server heartbeat. The heartbeat reply, including the timestamp
 * value, comes from the market data service.
 *
 * @generated from protobuf message md.Heartbeat
 */
export interface Heartbeat {
    /**
     * A request ID that is echoed back on the Heartbeat
     *
     * @generated from protobuf field: uint64 requestId = 1;
     */
    requestId: bigint;
    /**
     * @generated from protobuf field: uint64 timestamp = 2;
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message md.MdMessages
 */
export interface MdMessages {
    /**
     * @generated from protobuf field: repeated md.MdMessage messages = 1;
     */
    messages: MdMessage[];
}
/**
 * Every exchange message from `/tops` will be wrapped as an `AggMessage`.
 *
 * @generated from protobuf message md.AggMessage
 */
export interface AggMessage {
    /**
     * @generated from protobuf oneof: inner
     */
    inner: {
        oneofKind: "heartbeat";
        /**
         * Server heartbeat reply
         *
         * @generated from protobuf field: md.Heartbeat heartbeat = 1;
         */
        heartbeat: Heartbeat;
    } | {
        oneofKind: "topOfBooks";
        /**
         * Top of books
         *
         * @generated from protobuf field: md.TopOfBooks topOfBooks = 2;
         */
        topOfBooks: TopOfBooks;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Top of book
 *
 * @generated from protobuf message md.TopOfBook
 */
export interface TopOfBook {
    /**
     * @generated from protobuf field: uint64 marketId = 1;
     */
    marketId: bigint;
    /**
     * The [transact time](/docs/api_reference/trade#transact-time) of the latest
     * book update on this market.
     *
     * @generated from protobuf field: uint64 transactTime = 2;
     */
    transactTime: bigint;
    /**
     * The best bid price.
     *
     * @generated from protobuf field: uint64 bidPrice = 3;
     */
    bidPrice: bigint;
    /**
     * The total bid quantity at the best bid price.
     *
     * @generated from protobuf field: uint64 bidQuantity = 4;
     */
    bidQuantity: bigint;
    /**
     * The best ask price.
     *
     * @generated from protobuf field: uint64 askPrice = 5;
     */
    askPrice: bigint;
    /**
     * The total ask quantity at the best ask price.
     *
     * @generated from protobuf field: uint64 askQuantity = 6;
     */
    askQuantity: bigint;
    /**
     * The last trade price.
     *
     * @generated from protobuf field: uint64 lastPrice = 7;
     */
    lastPrice: bigint;
}
/**
 * Top of books for all books that were updates since the last top-of-books
 * message.
 *
 * @generated from protobuf message md.TopOfBooks
 */
export interface TopOfBooks {
    /**
     * @generated from protobuf field: repeated md.TopOfBook tops = 1;
     */
    tops: TopOfBook[];
}
/**
 * Client heartbeats and configs. This wrapper is used for both
 * `/book/:market_id` and `/tops`, but `config` messages are ignored on the
 * latter.
 *
 * @generated from protobuf message md.ClientMessage
 */
export interface ClientMessage {
    /**
     * @generated from protobuf oneof: inner
     */
    inner: {
        oneofKind: "heartbeat";
        /**
         * @generated from protobuf field: md.Heartbeat heartbeat = 1;
         */
        heartbeat: Heartbeat;
    } | {
        oneofKind: "config";
        /**
         * @generated from protobuf field: md.Config config = 2;
         */
        config: Config;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Set the message subscriptions for `/book/:market_id`. At most one of `mbp`
 * and `mbo` can be set.
 *
 * @generated from protobuf message md.Config
 */
export interface Config {
    /**
     * Enable MBP feeds
     *
     * @generated from protobuf field: bool mbp = 1;
     */
    mbp: boolean;
    /**
     * Enable MBO feeds
     *
     * @generated from protobuf field: bool mbo = 2;
     */
    mbo: boolean;
    /**
     * Enable recent trades
     *
     * @generated from protobuf field: bool trades = 3;
     */
    trades: boolean;
    /**
     * Enable 24h summary
     *
     * @generated from protobuf field: bool summary = 4;
     */
    summary: boolean;
    /**
     * Enable price klines
     *
     * @generated from protobuf field: repeated md.KlineInterval klines = 5;
     */
    klines: KlineInterval[];
}
/**
 * Side specifies whether the level, order, or diff, is for buying or selling
 * the base asset.
 *
 * @generated from protobuf enum md.Side
 */
export enum Side {
    /**
     * Bids buy the base asset with the quote asset.
     *
     * @generated from protobuf enum value: BID = 0;
     */
    BID = 0,
    /**
     * Asks (or offers) sell the base asset and get the quote asset.
     *
     * @generated from protobuf enum value: ASK = 1;
     */
    ASK = 1
}
/**
 * The candlestick interval.
 *
 * @generated from protobuf enum md.KlineInterval
 */
export enum KlineInterval {
    /**
     * 1 second
     *
     * @generated from protobuf enum value: S1 = 0;
     */
    S1 = 0,
    /**
     * 1 minute
     *
     * @generated from protobuf enum value: M1 = 1;
     */
    M1 = 1,
    /**
     * 15 minutes
     *
     * @generated from protobuf enum value: M15 = 2;
     */
    M15 = 2,
    /**
     * 1 hour
     *
     * @generated from protobuf enum value: H1 = 3;
     */
    H1 = 3,
    /**
     * 4 hours
     *
     * @generated from protobuf enum value: H4 = 4;
     */
    H4 = 4,
    /**
     * 1 day
     *
     * @generated from protobuf enum value: D1 = 5;
     */
    D1 = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class MdMessage$Type extends MessageType<MdMessage> {
    constructor() {
        super("md.MdMessage", [
            { no: 1, name: "heartbeat", kind: "message", oneof: "inner", T: () => Heartbeat },
            { no: 2, name: "summary", kind: "message", oneof: "inner", T: () => Summary },
            { no: 3, name: "trades", kind: "message", oneof: "inner", T: () => Trades },
            { no: 4, name: "mboSnapshot", kind: "message", oneof: "inner", T: () => MarketByOrder },
            { no: 5, name: "mboDiff", kind: "message", oneof: "inner", T: () => MarketByOrderDiff },
            { no: 6, name: "mbpSnapshot", kind: "message", oneof: "inner", T: () => MarketByPrice },
            { no: 7, name: "mbpDiff", kind: "message", oneof: "inner", T: () => MarketByPriceDiff },
            { no: 8, name: "kline", kind: "message", oneof: "inner", T: () => Kline }
        ]);
    }
    create(value?: PartialMessage<MdMessage>): MdMessage {
        const message = { inner: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MdMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MdMessage): MdMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* md.Heartbeat heartbeat */ 1:
                    message.inner = {
                        oneofKind: "heartbeat",
                        heartbeat: Heartbeat.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).heartbeat)
                    };
                    break;
                case /* md.Summary summary */ 2:
                    message.inner = {
                        oneofKind: "summary",
                        summary: Summary.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).summary)
                    };
                    break;
                case /* md.Trades trades */ 3:
                    message.inner = {
                        oneofKind: "trades",
                        trades: Trades.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).trades)
                    };
                    break;
                case /* md.MarketByOrder mboSnapshot */ 4:
                    message.inner = {
                        oneofKind: "mboSnapshot",
                        mboSnapshot: MarketByOrder.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).mboSnapshot)
                    };
                    break;
                case /* md.MarketByOrderDiff mboDiff */ 5:
                    message.inner = {
                        oneofKind: "mboDiff",
                        mboDiff: MarketByOrderDiff.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).mboDiff)
                    };
                    break;
                case /* md.MarketByPrice mbpSnapshot */ 6:
                    message.inner = {
                        oneofKind: "mbpSnapshot",
                        mbpSnapshot: MarketByPrice.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).mbpSnapshot)
                    };
                    break;
                case /* md.MarketByPriceDiff mbpDiff */ 7:
                    message.inner = {
                        oneofKind: "mbpDiff",
                        mbpDiff: MarketByPriceDiff.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).mbpDiff)
                    };
                    break;
                case /* md.Kline kline */ 8:
                    message.inner = {
                        oneofKind: "kline",
                        kline: Kline.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).kline)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MdMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* md.Heartbeat heartbeat = 1; */
        if (message.inner.oneofKind === "heartbeat")
            Heartbeat.internalBinaryWrite(message.inner.heartbeat, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* md.Summary summary = 2; */
        if (message.inner.oneofKind === "summary")
            Summary.internalBinaryWrite(message.inner.summary, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* md.Trades trades = 3; */
        if (message.inner.oneofKind === "trades")
            Trades.internalBinaryWrite(message.inner.trades, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* md.MarketByOrder mboSnapshot = 4; */
        if (message.inner.oneofKind === "mboSnapshot")
            MarketByOrder.internalBinaryWrite(message.inner.mboSnapshot, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* md.MarketByOrderDiff mboDiff = 5; */
        if (message.inner.oneofKind === "mboDiff")
            MarketByOrderDiff.internalBinaryWrite(message.inner.mboDiff, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* md.MarketByPrice mbpSnapshot = 6; */
        if (message.inner.oneofKind === "mbpSnapshot")
            MarketByPrice.internalBinaryWrite(message.inner.mbpSnapshot, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* md.MarketByPriceDiff mbpDiff = 7; */
        if (message.inner.oneofKind === "mbpDiff")
            MarketByPriceDiff.internalBinaryWrite(message.inner.mbpDiff, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* md.Kline kline = 8; */
        if (message.inner.oneofKind === "kline")
            Kline.internalBinaryWrite(message.inner.kline, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MdMessage
 */
export const MdMessage = new MdMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketByPrice$Type extends MessageType<MarketByPrice> {
    constructor() {
        super("md.MarketByPrice", [
            { no: 1, name: "levels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketByPrice_Level },
            { no: 2, name: "chunk", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "numChunks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MarketByPrice>): MarketByPrice {
        const message = { levels: [], chunk: 0, numChunks: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketByPrice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketByPrice): MarketByPrice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated md.MarketByPrice.Level levels */ 1:
                    message.levels.push(MarketByPrice_Level.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 chunk */ 2:
                    message.chunk = reader.uint32();
                    break;
                case /* uint32 numChunks */ 3:
                    message.numChunks = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketByPrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated md.MarketByPrice.Level levels = 1; */
        for (let i = 0; i < message.levels.length; i++)
            MarketByPrice_Level.internalBinaryWrite(message.levels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 chunk = 2; */
        if (message.chunk !== 0)
            writer.tag(2, WireType.Varint).uint32(message.chunk);
        /* uint32 numChunks = 3; */
        if (message.numChunks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.numChunks);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MarketByPrice
 */
export const MarketByPrice = new MarketByPrice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketByPrice_Level$Type extends MessageType<MarketByPrice_Level> {
    constructor() {
        super("md.MarketByPrice.Level", [
            { no: 1, name: "price", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "side", kind: "enum", T: () => ["md.Side", Side] }
        ]);
    }
    create(value?: PartialMessage<MarketByPrice_Level>): MarketByPrice_Level {
        const message = { price: 0n, quantity: 0n, side: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketByPrice_Level>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketByPrice_Level): MarketByPrice_Level {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 price */ 1:
                    message.price = reader.uint64().toBigInt();
                    break;
                case /* uint64 quantity */ 2:
                    message.quantity = reader.uint64().toBigInt();
                    break;
                case /* md.Side side */ 3:
                    message.side = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketByPrice_Level, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 price = 1; */
        if (message.price !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.price);
        /* uint64 quantity = 2; */
        if (message.quantity !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.quantity);
        /* md.Side side = 3; */
        if (message.side !== 0)
            writer.tag(3, WireType.Varint).int32(message.side);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MarketByPrice.Level
 */
export const MarketByPrice_Level = new MarketByPrice_Level$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketByPriceDiff$Type extends MessageType<MarketByPriceDiff> {
    constructor() {
        super("md.MarketByPriceDiff", [
            { no: 1, name: "diffs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketByPriceDiff_Diff },
            { no: 2, name: "totalBidLevels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "totalAskLevels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MarketByPriceDiff>): MarketByPriceDiff {
        const message = { diffs: [], totalBidLevels: 0, totalAskLevels: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketByPriceDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketByPriceDiff): MarketByPriceDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated md.MarketByPriceDiff.Diff diffs */ 1:
                    message.diffs.push(MarketByPriceDiff_Diff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 totalBidLevels */ 2:
                    message.totalBidLevels = reader.uint32();
                    break;
                case /* uint32 totalAskLevels */ 3:
                    message.totalAskLevels = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketByPriceDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated md.MarketByPriceDiff.Diff diffs = 1; */
        for (let i = 0; i < message.diffs.length; i++)
            MarketByPriceDiff_Diff.internalBinaryWrite(message.diffs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 totalBidLevels = 2; */
        if (message.totalBidLevels !== 0)
            writer.tag(2, WireType.Varint).uint32(message.totalBidLevels);
        /* uint32 totalAskLevels = 3; */
        if (message.totalAskLevels !== 0)
            writer.tag(3, WireType.Varint).uint32(message.totalAskLevels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MarketByPriceDiff
 */
export const MarketByPriceDiff = new MarketByPriceDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketByPriceDiff_Diff$Type extends MessageType<MarketByPriceDiff_Diff> {
    constructor() {
        super("md.MarketByPriceDiff.Diff", [
            { no: 1, name: "price", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "side", kind: "enum", T: () => ["md.Side", Side] },
            { no: 4, name: "op", kind: "enum", T: () => ["md.MarketByPriceDiff.DiffOp", MarketByPriceDiff_DiffOp] }
        ]);
    }
    create(value?: PartialMessage<MarketByPriceDiff_Diff>): MarketByPriceDiff_Diff {
        const message = { price: 0n, quantity: 0n, side: 0, op: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketByPriceDiff_Diff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketByPriceDiff_Diff): MarketByPriceDiff_Diff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 price */ 1:
                    message.price = reader.uint64().toBigInt();
                    break;
                case /* uint64 quantity */ 2:
                    message.quantity = reader.uint64().toBigInt();
                    break;
                case /* md.Side side */ 3:
                    message.side = reader.int32();
                    break;
                case /* md.MarketByPriceDiff.DiffOp op */ 4:
                    message.op = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketByPriceDiff_Diff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 price = 1; */
        if (message.price !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.price);
        /* uint64 quantity = 2; */
        if (message.quantity !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.quantity);
        /* md.Side side = 3; */
        if (message.side !== 0)
            writer.tag(3, WireType.Varint).int32(message.side);
        /* md.MarketByPriceDiff.DiffOp op = 4; */
        if (message.op !== 0)
            writer.tag(4, WireType.Varint).int32(message.op);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MarketByPriceDiff.Diff
 */
export const MarketByPriceDiff_Diff = new MarketByPriceDiff_Diff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketByOrder$Type extends MessageType<MarketByOrder> {
    constructor() {
        super("md.MarketByOrder", [
            { no: 1, name: "orders", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketByOrder_Order },
            { no: 2, name: "chunk", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "numChunks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MarketByOrder>): MarketByOrder {
        const message = { orders: [], chunk: 0, numChunks: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketByOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketByOrder): MarketByOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated md.MarketByOrder.Order orders */ 1:
                    message.orders.push(MarketByOrder_Order.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 chunk */ 2:
                    message.chunk = reader.uint32();
                    break;
                case /* uint32 numChunks */ 3:
                    message.numChunks = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketByOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated md.MarketByOrder.Order orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            MarketByOrder_Order.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 chunk = 2; */
        if (message.chunk !== 0)
            writer.tag(2, WireType.Varint).uint32(message.chunk);
        /* uint32 numChunks = 3; */
        if (message.numChunks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.numChunks);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MarketByOrder
 */
export const MarketByOrder = new MarketByOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketByOrder_Order$Type extends MessageType<MarketByOrder_Order> {
    constructor() {
        super("md.MarketByOrder.Order", [
            { no: 1, name: "price", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "exchangeOrderId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "side", kind: "enum", T: () => ["md.Side", Side] }
        ]);
    }
    create(value?: PartialMessage<MarketByOrder_Order>): MarketByOrder_Order {
        const message = { price: 0n, quantity: 0n, exchangeOrderId: 0n, side: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketByOrder_Order>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketByOrder_Order): MarketByOrder_Order {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 price */ 1:
                    message.price = reader.uint64().toBigInt();
                    break;
                case /* uint64 quantity */ 2:
                    message.quantity = reader.uint64().toBigInt();
                    break;
                case /* uint64 exchangeOrderId */ 3:
                    message.exchangeOrderId = reader.uint64().toBigInt();
                    break;
                case /* md.Side side */ 4:
                    message.side = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketByOrder_Order, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 price = 1; */
        if (message.price !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.price);
        /* uint64 quantity = 2; */
        if (message.quantity !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.quantity);
        /* uint64 exchangeOrderId = 3; */
        if (message.exchangeOrderId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.exchangeOrderId);
        /* md.Side side = 4; */
        if (message.side !== 0)
            writer.tag(4, WireType.Varint).int32(message.side);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MarketByOrder.Order
 */
export const MarketByOrder_Order = new MarketByOrder_Order$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketByOrderDiff$Type extends MessageType<MarketByOrderDiff> {
    constructor() {
        super("md.MarketByOrderDiff", [
            { no: 1, name: "diffs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketByOrderDiff_Diff },
            { no: 2, name: "totalBidLevels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "totalAskLevels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "totalBidOrders", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "totalAskOrders", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<MarketByOrderDiff>): MarketByOrderDiff {
        const message = { diffs: [], totalBidLevels: 0, totalAskLevels: 0, totalBidOrders: 0, totalAskOrders: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketByOrderDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketByOrderDiff): MarketByOrderDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated md.MarketByOrderDiff.Diff diffs */ 1:
                    message.diffs.push(MarketByOrderDiff_Diff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 totalBidLevels */ 2:
                    message.totalBidLevels = reader.uint32();
                    break;
                case /* uint32 totalAskLevels */ 3:
                    message.totalAskLevels = reader.uint32();
                    break;
                case /* uint32 totalBidOrders */ 4:
                    message.totalBidOrders = reader.uint32();
                    break;
                case /* uint32 totalAskOrders */ 5:
                    message.totalAskOrders = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketByOrderDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated md.MarketByOrderDiff.Diff diffs = 1; */
        for (let i = 0; i < message.diffs.length; i++)
            MarketByOrderDiff_Diff.internalBinaryWrite(message.diffs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 totalBidLevels = 2; */
        if (message.totalBidLevels !== 0)
            writer.tag(2, WireType.Varint).uint32(message.totalBidLevels);
        /* uint32 totalAskLevels = 3; */
        if (message.totalAskLevels !== 0)
            writer.tag(3, WireType.Varint).uint32(message.totalAskLevels);
        /* uint32 totalBidOrders = 4; */
        if (message.totalBidOrders !== 0)
            writer.tag(4, WireType.Varint).uint32(message.totalBidOrders);
        /* uint32 totalAskOrders = 5; */
        if (message.totalAskOrders !== 0)
            writer.tag(5, WireType.Varint).uint32(message.totalAskOrders);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MarketByOrderDiff
 */
export const MarketByOrderDiff = new MarketByOrderDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketByOrderDiff_Diff$Type extends MessageType<MarketByOrderDiff_Diff> {
    constructor() {
        super("md.MarketByOrderDiff.Diff", [
            { no: 1, name: "price", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "exchangeOrderId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "side", kind: "enum", T: () => ["md.Side", Side] },
            { no: 5, name: "op", kind: "enum", T: () => ["md.MarketByOrderDiff.OrderOp", MarketByOrderDiff_OrderOp] }
        ]);
    }
    create(value?: PartialMessage<MarketByOrderDiff_Diff>): MarketByOrderDiff_Diff {
        const message = { price: 0n, quantity: 0n, exchangeOrderId: 0n, side: 0, op: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketByOrderDiff_Diff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketByOrderDiff_Diff): MarketByOrderDiff_Diff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 price */ 1:
                    message.price = reader.uint64().toBigInt();
                    break;
                case /* uint64 quantity */ 2:
                    message.quantity = reader.uint64().toBigInt();
                    break;
                case /* uint64 exchangeOrderId */ 3:
                    message.exchangeOrderId = reader.uint64().toBigInt();
                    break;
                case /* md.Side side */ 4:
                    message.side = reader.int32();
                    break;
                case /* md.MarketByOrderDiff.OrderOp op */ 5:
                    message.op = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketByOrderDiff_Diff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 price = 1; */
        if (message.price !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.price);
        /* uint64 quantity = 2; */
        if (message.quantity !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.quantity);
        /* uint64 exchangeOrderId = 3; */
        if (message.exchangeOrderId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.exchangeOrderId);
        /* md.Side side = 4; */
        if (message.side !== 0)
            writer.tag(4, WireType.Varint).int32(message.side);
        /* md.MarketByOrderDiff.OrderOp op = 5; */
        if (message.op !== 0)
            writer.tag(5, WireType.Varint).int32(message.op);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MarketByOrderDiff.Diff
 */
export const MarketByOrderDiff_Diff = new MarketByOrderDiff_Diff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Trades$Type extends MessageType<Trades> {
    constructor() {
        super("md.Trades", [
            { no: 1, name: "trades", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Trades_Trade }
        ]);
    }
    create(value?: PartialMessage<Trades>): Trades {
        const message = { trades: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Trades>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Trades): Trades {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated md.Trades.Trade trades */ 1:
                    message.trades.push(Trades_Trade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Trades, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated md.Trades.Trade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            Trades_Trade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.Trades
 */
export const Trades = new Trades$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Trades_Trade$Type extends MessageType<Trades_Trade> {
    constructor() {
        super("md.Trades.Trade", [
            { no: 1, name: "tradeId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "price", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "aggressingSide", kind: "enum", T: () => ["md.Side", Side] },
            { no: 4, name: "restingExchangeOrderId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "fillQuantity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "transactTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "aggressingExchangeOrderId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Trades_Trade>): Trades_Trade {
        const message = { tradeId: 0n, price: 0n, aggressingSide: 0, restingExchangeOrderId: 0n, fillQuantity: 0n, transactTime: 0n, aggressingExchangeOrderId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Trades_Trade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Trades_Trade): Trades_Trade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 tradeId */ 1:
                    message.tradeId = reader.uint64().toBigInt();
                    break;
                case /* uint64 price */ 2:
                    message.price = reader.uint64().toBigInt();
                    break;
                case /* md.Side aggressingSide */ 3:
                    message.aggressingSide = reader.int32();
                    break;
                case /* uint64 restingExchangeOrderId */ 4:
                    message.restingExchangeOrderId = reader.uint64().toBigInt();
                    break;
                case /* uint64 fillQuantity */ 5:
                    message.fillQuantity = reader.uint64().toBigInt();
                    break;
                case /* uint64 transactTime */ 6:
                    message.transactTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 aggressingExchangeOrderId */ 7:
                    message.aggressingExchangeOrderId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Trades_Trade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 tradeId = 1; */
        if (message.tradeId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.tradeId);
        /* uint64 price = 2; */
        if (message.price !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.price);
        /* md.Side aggressingSide = 3; */
        if (message.aggressingSide !== 0)
            writer.tag(3, WireType.Varint).int32(message.aggressingSide);
        /* uint64 restingExchangeOrderId = 4; */
        if (message.restingExchangeOrderId !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.restingExchangeOrderId);
        /* uint64 fillQuantity = 5; */
        if (message.fillQuantity !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.fillQuantity);
        /* uint64 transactTime = 6; */
        if (message.transactTime !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.transactTime);
        /* uint64 aggressingExchangeOrderId = 7; */
        if (message.aggressingExchangeOrderId !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.aggressingExchangeOrderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.Trades.Trade
 */
export const Trades_Trade = new Trades_Trade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Summary$Type extends MessageType<Summary> {
    constructor() {
        super("md.Summary", [
            { no: 1, name: "low", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "high", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "baseVolumeLo", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "baseVolumeHi", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "quoteVolumeLo", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "quoteVolumeHi", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Summary>): Summary {
        const message = { low: 0n, high: 0n, baseVolumeLo: 0n, baseVolumeHi: 0n, quoteVolumeLo: 0n, quoteVolumeHi: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Summary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Summary): Summary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 low */ 1:
                    message.low = reader.uint64().toBigInt();
                    break;
                case /* uint64 high */ 2:
                    message.high = reader.uint64().toBigInt();
                    break;
                case /* uint64 baseVolumeLo */ 3:
                    message.baseVolumeLo = reader.uint64().toBigInt();
                    break;
                case /* uint64 baseVolumeHi */ 4:
                    message.baseVolumeHi = reader.uint64().toBigInt();
                    break;
                case /* uint64 quoteVolumeLo */ 5:
                    message.quoteVolumeLo = reader.uint64().toBigInt();
                    break;
                case /* uint64 quoteVolumeHi */ 6:
                    message.quoteVolumeHi = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Summary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 low = 1; */
        if (message.low !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.low);
        /* uint64 high = 2; */
        if (message.high !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.high);
        /* uint64 baseVolumeLo = 3; */
        if (message.baseVolumeLo !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.baseVolumeLo);
        /* uint64 baseVolumeHi = 4; */
        if (message.baseVolumeHi !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.baseVolumeHi);
        /* uint64 quoteVolumeLo = 5; */
        if (message.quoteVolumeLo !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.quoteVolumeLo);
        /* uint64 quoteVolumeHi = 6; */
        if (message.quoteVolumeHi !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.quoteVolumeHi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.Summary
 */
export const Summary = new Summary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Kline$Type extends MessageType<Kline> {
    constructor() {
        super("md.Kline", [
            { no: 1, name: "interval", kind: "enum", T: () => ["md.KlineInterval", KlineInterval] },
            { no: 2, name: "startTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "open", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "close", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "high", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "low", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "volumeLo", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "volumeHi", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Kline>): Kline {
        const message = { interval: 0, startTime: 0n, open: 0n, close: 0n, high: 0n, low: 0n, volumeLo: 0n, volumeHi: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Kline>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Kline): Kline {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* md.KlineInterval interval */ 1:
                    message.interval = reader.int32();
                    break;
                case /* uint64 startTime */ 2:
                    message.startTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 open */ 3:
                    message.open = reader.uint64().toBigInt();
                    break;
                case /* uint64 close */ 4:
                    message.close = reader.uint64().toBigInt();
                    break;
                case /* uint64 high */ 5:
                    message.high = reader.uint64().toBigInt();
                    break;
                case /* uint64 low */ 6:
                    message.low = reader.uint64().toBigInt();
                    break;
                case /* uint64 volumeLo */ 7:
                    message.volumeLo = reader.uint64().toBigInt();
                    break;
                case /* uint64 volumeHi */ 8:
                    message.volumeHi = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Kline, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* md.KlineInterval interval = 1; */
        if (message.interval !== 0)
            writer.tag(1, WireType.Varint).int32(message.interval);
        /* uint64 startTime = 2; */
        if (message.startTime !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.startTime);
        /* uint64 open = 3; */
        if (message.open !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.open);
        /* uint64 close = 4; */
        if (message.close !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.close);
        /* uint64 high = 5; */
        if (message.high !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.high);
        /* uint64 low = 6; */
        if (message.low !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.low);
        /* uint64 volumeLo = 7; */
        if (message.volumeLo !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.volumeLo);
        /* uint64 volumeHi = 8; */
        if (message.volumeHi !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.volumeHi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.Kline
 */
export const Kline = new Kline$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Heartbeat$Type extends MessageType<Heartbeat> {
    constructor() {
        super("md.Heartbeat", [
            { no: 1, name: "requestId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Heartbeat>): Heartbeat {
        const message = { requestId: 0n, timestamp: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Heartbeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Heartbeat): Heartbeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 requestId */ 1:
                    message.requestId = reader.uint64().toBigInt();
                    break;
                case /* uint64 timestamp */ 2:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Heartbeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 requestId = 1; */
        if (message.requestId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.requestId);
        /* uint64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.Heartbeat
 */
export const Heartbeat = new Heartbeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MdMessages$Type extends MessageType<MdMessages> {
    constructor() {
        super("md.MdMessages", [
            { no: 1, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MdMessage }
        ]);
    }
    create(value?: PartialMessage<MdMessages>): MdMessages {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MdMessages>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MdMessages): MdMessages {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated md.MdMessage messages */ 1:
                    message.messages.push(MdMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MdMessages, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated md.MdMessage messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            MdMessage.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.MdMessages
 */
export const MdMessages = new MdMessages$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggMessage$Type extends MessageType<AggMessage> {
    constructor() {
        super("md.AggMessage", [
            { no: 1, name: "heartbeat", kind: "message", oneof: "inner", T: () => Heartbeat },
            { no: 2, name: "topOfBooks", kind: "message", oneof: "inner", T: () => TopOfBooks }
        ]);
    }
    create(value?: PartialMessage<AggMessage>): AggMessage {
        const message = { inner: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AggMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggMessage): AggMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* md.Heartbeat heartbeat */ 1:
                    message.inner = {
                        oneofKind: "heartbeat",
                        heartbeat: Heartbeat.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).heartbeat)
                    };
                    break;
                case /* md.TopOfBooks topOfBooks */ 2:
                    message.inner = {
                        oneofKind: "topOfBooks",
                        topOfBooks: TopOfBooks.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).topOfBooks)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* md.Heartbeat heartbeat = 1; */
        if (message.inner.oneofKind === "heartbeat")
            Heartbeat.internalBinaryWrite(message.inner.heartbeat, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* md.TopOfBooks topOfBooks = 2; */
        if (message.inner.oneofKind === "topOfBooks")
            TopOfBooks.internalBinaryWrite(message.inner.topOfBooks, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.AggMessage
 */
export const AggMessage = new AggMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TopOfBook$Type extends MessageType<TopOfBook> {
    constructor() {
        super("md.TopOfBook", [
            { no: 1, name: "marketId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "transactTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "bidPrice", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "bidQuantity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "askPrice", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "askQuantity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "lastPrice", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TopOfBook>): TopOfBook {
        const message = { marketId: 0n, transactTime: 0n, bidPrice: 0n, bidQuantity: 0n, askPrice: 0n, askQuantity: 0n, lastPrice: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TopOfBook>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TopOfBook): TopOfBook {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 marketId */ 1:
                    message.marketId = reader.uint64().toBigInt();
                    break;
                case /* uint64 transactTime */ 2:
                    message.transactTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 bidPrice */ 3:
                    message.bidPrice = reader.uint64().toBigInt();
                    break;
                case /* uint64 bidQuantity */ 4:
                    message.bidQuantity = reader.uint64().toBigInt();
                    break;
                case /* uint64 askPrice */ 5:
                    message.askPrice = reader.uint64().toBigInt();
                    break;
                case /* uint64 askQuantity */ 6:
                    message.askQuantity = reader.uint64().toBigInt();
                    break;
                case /* uint64 lastPrice */ 7:
                    message.lastPrice = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TopOfBook, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 marketId = 1; */
        if (message.marketId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.marketId);
        /* uint64 transactTime = 2; */
        if (message.transactTime !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.transactTime);
        /* uint64 bidPrice = 3; */
        if (message.bidPrice !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.bidPrice);
        /* uint64 bidQuantity = 4; */
        if (message.bidQuantity !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.bidQuantity);
        /* uint64 askPrice = 5; */
        if (message.askPrice !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.askPrice);
        /* uint64 askQuantity = 6; */
        if (message.askQuantity !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.askQuantity);
        /* uint64 lastPrice = 7; */
        if (message.lastPrice !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.lastPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.TopOfBook
 */
export const TopOfBook = new TopOfBook$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TopOfBooks$Type extends MessageType<TopOfBooks> {
    constructor() {
        super("md.TopOfBooks", [
            { no: 1, name: "tops", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TopOfBook }
        ]);
    }
    create(value?: PartialMessage<TopOfBooks>): TopOfBooks {
        const message = { tops: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TopOfBooks>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TopOfBooks): TopOfBooks {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated md.TopOfBook tops */ 1:
                    message.tops.push(TopOfBook.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TopOfBooks, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated md.TopOfBook tops = 1; */
        for (let i = 0; i < message.tops.length; i++)
            TopOfBook.internalBinaryWrite(message.tops[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.TopOfBooks
 */
export const TopOfBooks = new TopOfBooks$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientMessage$Type extends MessageType<ClientMessage> {
    constructor() {
        super("md.ClientMessage", [
            { no: 1, name: "heartbeat", kind: "message", oneof: "inner", T: () => Heartbeat },
            { no: 2, name: "config", kind: "message", oneof: "inner", T: () => Config }
        ]);
    }
    create(value?: PartialMessage<ClientMessage>): ClientMessage {
        const message = { inner: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClientMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientMessage): ClientMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* md.Heartbeat heartbeat */ 1:
                    message.inner = {
                        oneofKind: "heartbeat",
                        heartbeat: Heartbeat.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).heartbeat)
                    };
                    break;
                case /* md.Config config */ 2:
                    message.inner = {
                        oneofKind: "config",
                        config: Config.internalBinaryRead(reader, reader.uint32(), options, (message.inner as any).config)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* md.Heartbeat heartbeat = 1; */
        if (message.inner.oneofKind === "heartbeat")
            Heartbeat.internalBinaryWrite(message.inner.heartbeat, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* md.Config config = 2; */
        if (message.inner.oneofKind === "config")
            Config.internalBinaryWrite(message.inner.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.ClientMessage
 */
export const ClientMessage = new ClientMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Config$Type extends MessageType<Config> {
    constructor() {
        super("md.Config", [
            { no: 1, name: "mbp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "mbo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "trades", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "summary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "klines", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["md.KlineInterval", KlineInterval] }
        ]);
    }
    create(value?: PartialMessage<Config>): Config {
        const message = { mbp: false, mbo: false, trades: false, summary: false, klines: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config): Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool mbp */ 1:
                    message.mbp = reader.bool();
                    break;
                case /* bool mbo */ 2:
                    message.mbo = reader.bool();
                    break;
                case /* bool trades */ 3:
                    message.trades = reader.bool();
                    break;
                case /* bool summary */ 4:
                    message.summary = reader.bool();
                    break;
                case /* repeated md.KlineInterval klines */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.klines.push(reader.int32());
                    else
                        message.klines.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool mbp = 1; */
        if (message.mbp !== false)
            writer.tag(1, WireType.Varint).bool(message.mbp);
        /* bool mbo = 2; */
        if (message.mbo !== false)
            writer.tag(2, WireType.Varint).bool(message.mbo);
        /* bool trades = 3; */
        if (message.trades !== false)
            writer.tag(3, WireType.Varint).bool(message.trades);
        /* bool summary = 4; */
        if (message.summary !== false)
            writer.tag(4, WireType.Varint).bool(message.summary);
        /* repeated md.KlineInterval klines = 5; */
        if (message.klines.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.klines.length; i++)
                writer.int32(message.klines[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message md.Config
 */
export const Config = new Config$Type();
